---
layout: post
title:  "Toykio"
author: "Alexander Polakov"
author_github: "polachok"
date:   2018-08-01
categories: blog
---

What is toykio?
---------------
[toykio](https://github.com/polachok/toykio) is a simple futures executor intended for learning about
how executors work. Toykio only provides minimal features: event loop, TcpStream and TcpListener, but it 
turns out that due to futures being composable this is enough to build complex clients and servers.

I'll give a quick overview of toykio components.

TcpStream
---------
AsyncTcpStream is defined as a newtype wrapper around TcpStream from standard library. `connect`
function opens a connection, just like in std, and sets socket to nonblocking mode. This means
that read() and write() functions will return immediately, either with data or an error. If there's not enough data (for reads) or buffer space (for writes) avaialble, a special kind of error - `WouldBlock` - is returned. We'll discuss how to handle them in the next section.

AsyncRead & AsyncWrite
----------------------
AsyncRead and AsyncWrite traits are the foundation of all I/O futures. FutureReadExt and FutureWriteExt
extension methods (like `write_all`) are built on top of them. This makes `futures` crate independent of
the event loop implementation.
`AsyncRead` and `AsyncWrite` implementations provide this connection between futures and the reactor. 

Let's take a look at 
[AsyncRead](https://github.com/polachok/toykio/blob/futures-0.3/src/lib.rs#L327) for example:

```rust
impl AsyncRead for AsyncTcpStream {
    fn poll_read(&mut self, cx: &mut Context, buf: &mut [u8]) -> Poll<Result<usize, Error>> {
	// get TcpStream file descriptor
        let fd = self.0.as_raw_fd();
        let waker = cx.waker();

        match self.0.read(buf) {
            Ok(len) => Poll::Ready(Ok(len)),
            Err(ref err) if err.kind() == std::io::ErrorKind::WouldBlock => {
                REACTOR.with(|reactor| reactor.add_read_interest(fd, waker.clone()));

                Poll::Pending
            }
            Err(err) => panic!("error {:?}", err),
        }
    }
}
```
It tries to perform a read on the underlying TcpStream, and registers its interest in `readable`
event if `WouldBlock` is returned. This is explained in the next section.

[AsyncWrite](https://github.com/polachok/toykio/blob/futures-0.3/src/lib.rs#L346) does
the same thing for writes.

Event loop
----------
[Event loop](https://github.com/polachok/toykio/blob/futures-0.3/src/lib.rs#L108)
(or reactor) is the core of the executor. It is defined like this:

```
struct InnerEventLoop {
    read: RefCell<BTreeMap<RawFd, Waker>>,
    write: RefCell<BTreeMap<RawFd, Waker>>,
    counter: Cell<usize>,
    wait_queue: RefCell<Vec<Task>>,
    run_queue: RefCell<VecDeque<Wakeup>>,
}
```
read and write are maps from file descriptors to future Wakers. There're also two queues, one for tasks blocked waiting for an event (`wait_queue`) and the other for futures ready to run (`run_queue`). 

Event loop provides methods to
[register](https://github.com/polachok/toykio/blob/futures-0.3/src/lib.rs#L133) (and remove) 
interest in read and write events.
Let's look at what `add_read_interest` does:

```rust
fn add_read_interest(&self, fd: RawFd, waker: Waker) {
        if !self.read.borrow().contains_key(&fd) {
            self.read.borrow_mut().insert(fd, waker);
        }
}
```

But it just inserts fd and Waker into read map! So where does all the magic happen?
In the [main loop](https://github.com/polachok/toykio/blob/futures-0.3/src/lib.rs#L192).
Event loop is called a loop for a reason. Let's take a look:

```rust
loop {
    // event loop iteration timeout. if no descriptor
    // is ready we continue iterating
    let mut tv: timeval = timeval {
	tv_sec: 1,
	tv_usec: 0,
    };

    // initialize fd_sets (file descriptor sets)
    let mut read_fds: fd_set = unsafe { std::mem::zeroed() };
    let mut write_fds: fd_set = unsafe { std::mem::zeroed() };

    unsafe { FD_ZERO(&mut read_fds) };
    unsafe { FD_ZERO(&mut write_fds) };
```
Woah, woah, a lot of `unsafe` here! Well, don't worry, it's just how C FFI works. We need
to initialize some C structures, timeout and fd_sets. They will be later passed to the select(2)
function.

```rust
    // add read interests to read fd_sets
    for fd in self.read.borrow().keys() {
	unsafe { FD_SET(*fd, &mut read_fds as *mut fd_set) };
	nfds = std::cmp::max(nfds, fd + 1);
    }

    // add write interests to write fd_sets
    for fd in self.write.borrow().keys() {
	unsafe { FD_SET(*fd, &mut write_fds as *mut fd_set) };
	nfds = std::cmp::max(nfds, fd + 1);
    }
```
Here we add file descriptors from our read and write maps from before to the fd_sets.

```rust
    // select will block until some event happens
    // on the fds or timeout triggers
    let rv = unsafe {
	select(
	    nfds,
	    &mut read_fds,
	    &mut write_fds,
	    std::ptr::null_mut(),
	    &mut tv,
	)
    };

    // don't care for errors
    if rv == -1 {
	panic!("select()");
    } else if rv == 0 {
	debug!("timeout");
    } else {
	debug!("data available on {} fds", rv);
    }
```
Finally we call select with arguments we prepared earlier. select() accepts 3
fd_sets (we ignore the third for this example) and a timeout. 
And returns something non-zero in case one (or more) of the file descriptors in the sets are ready. We should then go and find which one it was!

```rust
    // check which fd it was and put appropriate future on run queue
    for (fd, waker) in self.read.borrow().iter() {
	let is_set = unsafe { FD_ISSET(*fd, &mut read_fds as *mut fd_set) };
	if is_set {
	    waker.wake();
	}
    }

    // same for write
    for (fd, waker) in self.write.borrow().iter() {
	let is_set = unsafe { FD_ISSET(*fd, &mut write_fds as *mut fd_set) };
	if is_set {
	    waker.wake();
	}
    }
```
We go through our maps again and check if they're set (ready) in fd_sets. When they're, we
call `wake` on their associated wakers, which in turn puts Wakeup events on the ready-to-run queue.

```rust
    let mut tasks_done = Vec::new();

    // now pop futures from the run queue and poll them
    while let Some(w) = self.run_queue.borrow_mut().pop_front() {
	let mut handle = self.handle();

	// if a task returned Ready - we're done with it
	if let Some(ref mut task) = self.wait_queue.borrow_mut().get_mut(w.index) {
	    if let Poll::Ready(_) = task.poll(w.waker, &mut handle) {
		tasks_done.push(w.index);
	    }
	}
    }

    // remove completed tasks
    for idx in tasks_done {
	self.wait_queue.borrow_mut().remove(idx);
    }

    // stop the loop if no more tasks
    if self.wait_queue.borrow().is_empty() {
	return;
    }
```
We drain the run_queue, retrieve task index on the wait_queue and poll tasks. Ready (done) tasks are removed from the wait_queue.
